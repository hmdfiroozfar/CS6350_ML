# -*- coding: utf-8 -*-
"""Untitled50.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19-0llub9BiGnZ9KsQo9268RsHN1fhmqS
"""

from scipy.optimize import minimize
import numpy as np
import pandas as pd

class Dual_SVM:
    def __init__(self, C):
        self.C = C
        self.weight_vector = None
        self.bias = None

    def _dual_objective(self, alphas, feature_matrix, labels):
        return 0.5 * np.dot(alphas * labels, np.dot(feature_matrix, feature_matrix.T).dot(alphas * labels)) - np.sum(alphas)

    def _constraint_equation(self, alphas, labels):
        return np.dot(alphas, labels)

    def fit(self, feature_matrix, labels):
        num_samples = feature_matrix.shape[0]
        initial_alphas = np.zeros(num_samples)
        bounds = [(0, self.C) for _ in range(num_samples)]
        constraints = {'type': 'eq', 'fun': self._constraint_equation, 'args': (labels,)}

        result = minimize(fun=self._dual_objective,
                          x0=initial_alphas,
                          args=(feature_matrix, labels),
                          method='SLSQP',
                          bounds=bounds,
                          constraints=constraints)

        alphas = result.x
        self.weight_vector = np.sum((alphas * labels)[:, np.newaxis] * feature_matrix, axis=0)
        support_mask = (alphas > 1e-4) & (alphas < self.C)
        support_vectors = feature_matrix[support_mask]
        support_labels = labels[support_mask]
        self.bias = np.mean(support_labels - np.dot(support_vectors, self.weight_vector))

    def predict(self, feature_matrix):
        return np.sign(np.dot(feature_matrix, self.weight_vector) + self.bias)

    def calculate_error(self, true_labels, predicted_labels):
        return np.mean(true_labels != predicted_labels)



C_values = [100/873, 500/873, 700/873]

path_to_train = 'train.csv'
path_to_test = 'test.csv'

train_data =pd.read_csv(path_to_train, header=None)
test_data = pd.read_csv(path_to_test, header=None)

X_train = train_data.iloc[:, :-1].values
y_train = train_data.iloc[:, -1].values
y_train = np.where(y_train == 0, -1, 1)

X_test = test_data.iloc[:, :-1].values
y_test = test_data.iloc[:, -1].values
y_test = np.where(y_test == 0, -1, 1)


for C in C_values:
    svm_classifier = Dual_SVM(C)
    svm_classifier.fit(X_train, y_train)
    y_train_pred = svm_classifier.predict(X_train)
    y_test_pred = svm_classifier.predict(X_test)
    train_error = svm_classifier.calculate_error(y_train, y_train_pred)
    test_error = svm_classifier.calculate_error(y_test, y_test_pred)
    print(f'\nDual SVM for C={C}\n\t Recovered weights= {svm_classifier.weight_vector}, bias= {svm_classifier.bias}')
    print(f'\t Train error is {train_error:.4f}, Test Error is: {test_error:.4f}')